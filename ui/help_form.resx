<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="textBox2.Text" xml:space="preserve">
    <value>At this time, the Hotkeys can not be changed. They are as follows

Navigating witin the current pane:
Ctrl-[right-arrow], Ctrl-[left-arrow] 
- Move between views (tabs)
Home, End, PgUp, PgDown, Up-arrow, Down-arrow 
- Move within the current view (tab). These work no matter what control has focus.
Ctrl-[up-arrow], Ctrl-[down-arrow]
- scroll up/down


Navigating within panes:
Tab/Shift-Tab
- navigates within the important panes. There are 3 important panes, 
  not all of them may be visible at a given time:
  The Filter Pane (left-most pane) - you can toggle it on/off
  The Views Pane - this shows all the views for the current log file (can NOT be hidden)
  The Full Log Pane (right-most pane) - you can toggle it on/off


Searching:
Ctrl-F 
- Start searching for a text within the current view (tab). Note: once you search for a text, 
  by default, we mark all the lines that contain that text
Escape
- Ends the search. All lines that were marked as "containing text", are now unmarked.

Searching Next/Prev:
F3, Shift-F3
- These are context dependent:
  If there is a Search running (you end a search by pressing Escape),
  it will continue to search for that text within the current view (tab), by going Next/Prev.  
  If there is no Search running, they will navigate through the selected Filter (in the filter pane), 
  showing exactly the lines that match that specific filter.

Clipboard:
Ctrl-C
- Copies current message to clipboard (excluding date/time, level, etc.)
Ctrl-Shift-C
- Copies full line to clipboard (including date/time, level, etc.)


Font:
+/-
- Increase/Decrease the current font size

Bookmarks:
Ctrl-F2
- Mark current line as a bookmark
Ctrl-Shift-F2
- Clear all existing bookmarks
F2, Shift-F2
- Move to next/previous bookmark


Toggle Hotkeys:
F, S, L
- Show/Hide Filters, Show/Hide Source, Show/Hide full Log
  These work ONLY if not on an Edit (text box) control
H
- Toggle History: this allows you to focus directly on the History, and it shows you the 
  full list of log files in the history. You can easily select one and it will load it.
  You can easily toggle back to whatever you were doing by pressing H again.
M
- Toggle showing log-message only 
  If turned on, only the message is shown (no time/date/level/etc)
  If turned off, all message info is shown
  
  
Miscellaneous
Ctrl-N
- New Log Wizard window  
Ctrl-S
- Show Settings window</value>
  </data>
  <data name="textBox1.Text" xml:space="preserve">
    <value>Column names are like this: $(ColumnName)
Each line_idx can be:
- a condition, or 
- an addition (=meaning, surrounding line_idxs should be added to the filter), or
- a color/font line_idx

Conditions:
$ColumnName Comparison Text
Comparison is = (equal), != (not equal), startswith, !startswith, contains, !contains
All conditions are ANDed.

Additions:
+ &lt;number_of_line_idxs&gt;
+ &lt;number_of_milliseconds&gt;ms
- &lt;number_of_line_idxs&gt;
- &lt;number_of_milliseconds&gt;ms

For + (something), we will include the following line_idxs in the log_line_idx_parser. 
For - (something), we wil include the previous line_idxs in the log_line_idx_parser

Font/Color:
color foreground [background]
The colors are specified in hexa (#RRGGBB). Common colors can be specified by name (e.g., Red, Blue, Yellow, etc)

Examples:
1: $msg startswith [click]
2: $msg) !startswith [pot]
3: $msg !contains hotkey
4: +100ms
5: -12
6: $level = ERROR
7: color red lightgray

Line 1: include all messages that start with [click]
Line 2: exclude all line_idxs all line_idxs tarting with [pot]
Line 3: excludes all line_idxs containing the word hotkey
Line 4: for each included line_idx, also include the next line_idxs logged within 100 milliseconds
Line 5: for each included line_idx, also include the previous 12 logged line_idxs
Line 6: include all line_idxs that have level is ERROR
Line 7: set the color as red (foreground) on lightgray (background)
</value>
  </data>
</root>